<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>wall netwark "wallchat" - Firewallå›é¿æ©Ÿèƒ½ä»˜ã</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: sans-serif; padding: 20px; background: #f5f5f5; }
        .container { max-width: 800px; margin: 0 auto; }
        .card { background: white; border-radius: 10px; padding: 20px; margin-bottom: 20px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        h1 { color: #333; margin-bottom: 10px; }
        h2 { color: #666; margin-bottom: 15px; font-size: 18px; }
        input, textarea, button { width: 100%; padding: 10px; margin: 5px 0; border: 1px solid #ddd; border-radius: 5px; }
        button { background: #4CAF50; color: white; border: none; cursor: pointer; font-weight: bold; }
        button:hover { background: #45a049; }
        button.secondary { background: #2196F3; }
        button.secondary:hover { background: #0b7dda; }
        button.danger { background: #f44336; }
        button.danger:hover { background: #d32f2f; }
        .status { padding: 10px; border-radius: 5px; margin: 10px 0; background: #e3f2fd; border-left: 4px solid #2196F3; }
        .status.error { background: #ffebee; border-left-color: #f44336; }
        .status.success { background: #e8f5e8; border-left-color: #4CAF50; }
        .status.warning { background: #fff3cd; border-left-color: #ffc107; color: #856404; }
        #messages { height: 300px; overflow-y: auto; border: 1px solid #ddd; padding: 10px; margin: 10px 0; background: white; }
        .message { margin-bottom: 10px; padding: 8px; border-radius: 5px; }
        .message.own { background: #e3f2fd; text-align: right; }
        .message.other { background: #f5f5f5; }
        .peer-list { list-style: none; margin: 10px 0; }
        .peer-item { padding: 5px 10px; background: #f8f9fa; margin: 2px 0; border-radius: 3px; display: flex; justify-content: space-between; }
        .hidden { display: none; }
        
        /* æ¥ç¶šæƒ…å ±è¡¨ç¤º */
        .connection-info {
            background: #f8f9fa;
            padding: 12px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            margin: 10px 0;
            border: 1px solid #dee2e6;
            font-size: 14px;
            max-height: 100px;
            overflow-y: auto;
        }
        
        /* æ‹›å¾…ã‚³ãƒ¼ãƒ‰è¡¨ç¤ºç”¨ã‚¹ã‚¿ã‚¤ãƒ« */
        .invite-code-display {
            background: #f8f9fa;
            padding: 12px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            word-break: break-all;
            margin: 10px 0;
            border: 1px solid #dee2e6;
            cursor: pointer;
            font-size: 14px;
            max-height: 100px;
            overflow-y: auto;
        }
        .invite-code-display:hover {
            background: #e9ecef;
        }
        .copy-btn {
            width: auto;
            padding: 8px 16px;
            margin: 0;
        }
        .invite-section {
            background: #f0f7ff;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border: 1px solid #cce5ff;
        }
        
        /* é€šçŸ¥ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ */
        @keyframes fadeInOut {
            0% { opacity: 0; transform: translateY(-20px); }
            15% { opacity: 1; transform: translateY(0); }
            85% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-20px); }
        }
        
        /* æ‹›å¾…ãƒªãƒ³ã‚¯å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ */
        .link-input {
            font-family: 'Courier New', monospace;
            font-size: 14px;
            background: #f8f9fa;
        }
        
        /* ãƒ«ãƒ¼ãƒ æƒ…å ±ã‚’å¼·èª¿è¡¨ç¤º */
        .room-info-top {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        .room-info-top h2 {
            color: white;
            margin-top: 0;
            font-size: 20px;
        }
        .invite-code-top {
            background: rgba(255,255,255,0.2);
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            font-size: 16px;
            word-break: break-all;
            font-family: 'Courier New', monospace;
            border: 2px dashed rgba(255,255,255,0.3);
        }
        .top-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 15px;
        }
        .top-buttons button {
            flex: 1;
            min-width: 120px;
        }
        
        /* è¨­å®šãƒ‘ãƒãƒ« */
        .settings-panel {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            border: 1px solid #dee2e6;
        }
        .settings-toggle {
            background: #6c757d;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            margin-bottom: 10px;
        }
        .settings-toggle:hover {
            background: #5a6268;
        }
        .settings-content {
            display: none;
            margin-top: 10px;
        }
        .settings-content.show {
            display: block;
        }
        
        /* æ¥ç¶šè¨ºæ–­ */
        .diagnostic-info {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-size: 13px;
        }
        .connection-type {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
            margin-left: 10px;
        }
        .direct { background: #d4edda; color: #155724; }
        .relay { background: #f8d7da; color: #721c24; }
        .nat { background: #fff3cd; color: #856404; }
    </style>
</head>
<body>
    <div class="container">
        <!-- ä¸€ç•ªä¸Šã®æ‹›å¾…ã‚³ãƒ¼ãƒ‰è¡¨ç¤ºã‚¨ãƒªã‚¢ -->
        <div id="inviteCodeTop" class="room-info-top hidden">
            <h2>ğŸ‰ ãƒ«ãƒ¼ãƒ ä½œæˆå®Œäº†ï¼ (Firewallå›é¿æ©Ÿèƒ½ä»˜ã)</h2>
            <div style="margin-bottom: 10px;">
                <strong>ãƒ«ãƒ¼ãƒ ID:</strong> <span id="roomIdTop"></span>
            </div>
            <div style="margin-bottom: 15px;">
                <strong>æ‹›å¾…ã‚³ãƒ¼ãƒ‰:</strong>
                <div class="invite-code-top" id="inviteCodeTopDisplay" onclick="copyInviteCode()" title="ã‚¯ãƒªãƒƒã‚¯ã§ã‚³ãƒ”ãƒ¼">
                    ã‚³ãƒ¼ãƒ‰ã‚’ç”Ÿæˆä¸­...
                </div>
            </div>
            
            <div class="top-buttons">
                <button onclick="copyInviteCode()" style="background: white; color: #667eea;">ğŸ“‹ ã‚³ãƒ¼ãƒ‰ã‚’ã‚³ãƒ”ãƒ¼</button>
                <button onclick="generateInviteLink()" style="background: rgba(255,255,255,0.2); border: 1px solid white;">ğŸ”— ãƒªãƒ³ã‚¯ã‚’ç”Ÿæˆ</button>
                <button onclick="showQRCode()" style="background: rgba(255,255,255,0.2); border: 1px solid white;">ğŸ“± QRã‚³ãƒ¼ãƒ‰</button>
            </div>
            
            <div id="inviteLinkTopContainer" style="display: none; margin-top: 15px; background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px;">
                <label><strong>æ‹›å¾…ãƒªãƒ³ã‚¯:</strong></label>
                <div style="display: flex; gap: 5px; margin-top: 5px;">
                    <input type="text" id="inviteLinkTop" readonly style="flex: 1; padding: 8px; border-radius: 4px; border: none;">
                    <button onclick="copyInviteLink()" style="width: auto; padding: 8px 12px; background: white; color: #667eea;">ğŸ“‹</button>
                </div>
            </div>
            
            <!-- æ¥ç¶šè¨ºæ–­æƒ…å ± -->
            <div id="connectionDiagnostic" class="diagnostic-info hidden" style="margin-top: 15px; background: rgba(255,255,255,0.9); color: #333;">
                <strong>ğŸ“Š æ¥ç¶šè¨ºæ–­:</strong> <span id="connectionStatusText">è¨ºæ–­ä¸­...</span>
                <span id="connectionTypeBadge" class="connection-type hidden"></span>
            </div>
        </div>

        <!-- æ¥ç¶šè¨­å®š -->
        <div class="card">
            <h1>ğŸ”— wallchat (KDP) Vr 2.3.1</h1>
            <p>Created:Nova Notions(Nn)Team - <strong>Firewallå›é¿æ©Ÿèƒ½ä»˜ã</strong></p>
            <p style="font-size: 12px; color: #666; margin-top: 5px;">é«˜åº¦ãªNATè¶Šãˆãƒ»ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«å›é¿æ©Ÿèƒ½ã‚’æ­è¼‰</p>
            
            <div class="status" id="status">åˆæœŸåŒ–ä¸­...</div>
            
            <!-- è©³ç´°è¨­å®šãƒœã‚¿ãƒ³ -->
            <button class="settings-toggle" onclick="toggleSettings()">âš™ï¸ è©³ç´°è¨­å®š</button>
            
            <div id="advancedSettings" class="settings-content">
                <div class="settings-panel">
                    <h3 style="margin-bottom: 10px;">æ¥ç¶šè¨­å®š</h3>
                    <label><input type="checkbox" id="useCustomSTUN" checked> ã‚«ã‚¹ã‚¿ãƒ STUN/TURNã‚µãƒ¼ãƒãƒ¼ã‚’ä½¿ç”¨</label>
                    <div id="customServerSettings" style="margin-top: 10px;">
                        <label>STUNã‚µãƒ¼ãƒãƒ¼:</label>
                        <input type="text" id="stunServer" value="stun.l.google.com:19302" placeholder="stunã‚µãƒ¼ãƒãƒ¼ã‚¢ãƒ‰ãƒ¬ã‚¹">
                        <label>ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—STUN:</label>
                        <input type="text" id="stunBackup" value="stun1.l.google.com:19302" placeholder="ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—stunã‚µãƒ¼ãƒãƒ¼">
                        <label>TURNã‚µãƒ¼ãƒãƒ¼ (ã‚ªãƒ—ã‚·ãƒ§ãƒ³):</label>
                        <input type="text" id="turnServer" value="" placeholder="turn:server:port (ãƒ¦ãƒ¼ã‚¶ãƒ¼å:ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å½¢å¼)">
                        <small style="color: #666;">TURNã‚µãƒ¼ãƒãƒ¼ã¯ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«ã‚’ç¢ºå®Ÿã«é€šéã§ãã¾ã™ãŒã€è¨­å®šãŒå¿…è¦ã§ã™</small>
                    </div>
                    <div style="margin-top: 10px;">
                        <label><input type="checkbox" id="enableRelay" checked> ãƒªãƒ¬ãƒ¼æ¥ç¶šã‚’æœ‰åŠ¹åŒ– (ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«å¯¾ç­–)</label><br>
                        <label><input type="checkbox" id="forceTcp" > TCPæ¥ç¶šã‚’å¼·åˆ¶ (ä¸€éƒ¨ã®ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«å¯¾ç­–)</label>
                    </div>
                    <button onclick="saveSettings()" style="margin-top: 10px; padding: 8px 16px;">è¨­å®šã‚’ä¿å­˜</button>
                </div>
            </div>
            
            <div id="setupSection">
                <h2>1. ãƒ¦ãƒ¼ã‚¶ãƒ¼åè¨­å®š</h2>
                <input type="text" id="username" placeholder="ãƒ¦ãƒ¼ã‚¶ãƒ¼åã‚’å…¥åŠ›" value="ãƒ¦ãƒ¼ã‚¶ãƒ¼">
                <button id="setupBtn">è¨­å®šå®Œäº†</button>
            </div>
            
            <div id="connectSection" class="hidden">
                <h2>2. æ¥ç¶šè¨­å®š</h2>
                <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                    <button id="createRoomBtn" class="secondary">æ–°è¦ãƒ«ãƒ¼ãƒ ä½œæˆ</button>
                    <input type="text" id="roomCodeInput" placeholder="æ‹›å¾…ã‚³ãƒ¼ãƒ‰ã‚’è²¼ã‚Šä»˜ã‘ï¼ˆå‚åŠ æ™‚ã®ã¿ï¼‰">
                    <button id="joinRoomBtn">ãƒ«ãƒ¼ãƒ ã«å‚åŠ </button>
                </div>
                
                <!-- æ¥ç¶šãƒ˜ãƒ«ãƒ—æƒ…å ± -->
                <div class="connection-info">
                    <strong>æ¥ç¶šãƒ’ãƒ³ãƒˆ:</strong>
                    <ul style="margin: 5px 0 5px 20px; font-size: 12px;">
                        <li>ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«ç’°å¢ƒã§ã‚‚æ¥ç¶šã§ãã‚‹ã‚ˆã†è¤‡æ•°ã®ã‚µãƒ¼ãƒãƒ¼ã‚’è©¦ã—ã¾ã™</li>
                        <li>æ¥ç¶šã«å¤±æ•—ã™ã‚‹å ´åˆã¯ã€Œè©³ç´°è¨­å®šã€ã§ã‚µãƒ¼ãƒãƒ¼ã‚’å¤‰æ›´ã—ã¦ã¿ã¦ãã ã•ã„</li>
                        <li>å…¬å…±ã®Wi-Fiã§ã¯WebRTCãŒåˆ¶é™ã•ã‚Œã¦ã„ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- å‚åŠ è€…ãƒªã‚¹ãƒˆ -->
        <div class="card hidden" id="peersSection">
            <h2>ğŸ‘¥ å‚åŠ è€… (<span id="peerCount">1</span>äºº)</h2>
            <div id="connectionStats" class="diagnostic-info hidden">
                <strong>æ¥ç¶šçµ±è¨ˆ:</strong> 
                <span id="directConnections">0</span> ç›´æ¥æ¥ç¶š / 
                <span id="relayConnections">0</span> ãƒªãƒ¬ãƒ¼æ¥ç¶š / 
                <span id="failedConnections">0</span> å¤±æ•—
            </div>
            <ul class="peer-list" id="peerList">
                <li class="peer-item">ã‚ãªãŸ (æ¥ç¶šå¾…æ©Ÿä¸­...)</li>
            </ul>
        </div>

        <!-- ãƒãƒ£ãƒƒãƒˆç”»é¢ -->
        <div class="card hidden" id="chatSection">
            <h2>ğŸ’¬ ãƒãƒ£ãƒƒãƒˆ</h2>
            <div id="messages">
                <div class="message">ã‚·ã‚¹ãƒ†ãƒ : ãƒ«ãƒ¼ãƒ ã«å‚åŠ ã—ã¾ã—ãŸ</div>
            </div>
            
            <div style="display: flex; gap: 10px;">
                <input type="text" id="messageInput" placeholder="ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å…¥åŠ›..." autocomplete="off">
                <button id="sendBtn" style="width: auto;">é€ä¿¡</button>
            </div>
            
            <div style="display: flex; gap: 10px; margin-top: 10px;">
                <button id="testConnectionBtn" class="secondary" style="width: auto;">æ¥ç¶šãƒ†ã‚¹ãƒˆ</button>
                <button id="leaveBtn" class="danger" style="flex: 1;">ãƒ«ãƒ¼ãƒ ã‚’é€€å‡º</button>
            </div>
        </div>
        
        <!-- æ¥ç¶šãƒ†ã‚¹ãƒˆçµæœ -->
        <div id="testResults" class="card hidden">
            <h2>ğŸ” æ¥ç¶šãƒ†ã‚¹ãƒˆçµæœ</h2>
            <div id="testResultsContent"></div>
            <button onclick="document.getElementById('testResults').classList.add('hidden')" style="margin-top: 10px;">é–‰ã˜ã‚‹</button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <script>
        class FirewallBypassP2PChat {
            constructor() {
                this.peer = null;
                this.peerId = null;
                this.username = 'ãƒ¦ãƒ¼ã‚¶ãƒ¼';
                this.connections = new Map();
                this.roomId = null;
                this.isHost = false;
                this.inviteCode = null;
                
                // æ¥ç¶šçµ±è¨ˆ
                this.connectionStats = {
                    direct: 0,
                    relay: 0,
                    failed: 0,
                    totalAttempts: 0
                };
                
                // è¨­å®š
                this.settings = {
                    useCustomSTUN: true,
                    enableRelay: true,
                    forceTcp: false,
                    stunServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' },
                        { urls: 'stun:stun2.l.google.com:19302' },
                        { urls: 'stun:stun3.l.google.com:19302' },
                        { urls: 'stun:stun4.l.google.com:19302' }
                    ],
                    turnServers: [],
                    iceTransportPolicy: 'all'
                };
                
                this.init();
            }
            
            async init() {
                // è¨­å®šã®èª­ã¿è¾¼ã¿
                this.loadSettings();
                
                // ãƒ¦ãƒ¼ã‚¶ãƒ¼åã‚’è¨­å®š
                document.getElementById('setupBtn').addEventListener('click', () => {
                    const username = document.getElementById('username').value.trim() || 'ãƒ¦ãƒ¼ã‚¶ãƒ¼';
                    this.setUsername(username);
                });
                
                // ãƒ«ãƒ¼ãƒ ä½œæˆ
                document.getElementById('createRoomBtn').addEventListener('click', () => {
                    this.createRoom();
                });
                
                // ãƒ«ãƒ¼ãƒ å‚åŠ 
                document.getElementById('joinRoomBtn').addEventListener('click', () => {
                    const inviteCode = document.getElementById('roomCodeInput').value.trim();
                    if (inviteCode) {
                        this.joinRoom(inviteCode);
                    } else {
                        this.showNotification('æ‹›å¾…ã‚³ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„', true);
                    }
                });
                
                // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡
                document.getElementById('sendBtn').addEventListener('click', () => {
                    this.sendMessage();
                });
                
                document.getElementById('messageInput').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.sendMessage();
                });
                
                // ãƒ«ãƒ¼ãƒ é€€å‡º
                document.getElementById('leaveBtn').addEventListener('click', () => {
                    this.leaveRoom();
                });
                
                // æ¥ç¶šãƒ†ã‚¹ãƒˆ
                document.getElementById('testConnectionBtn').addEventListener('click', () => {
                    this.runConnectionTest();
                });
                
                // è¨­å®šå¤‰æ›´
                document.getElementById('useCustomSTUN').addEventListener('change', (e) => {
                    document.getElementById('customServerSettings').style.display = 
                        e.target.checked ? 'block' : 'none';
                });
                
                // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚ã«æ‹›å¾…ã‚³ãƒ¼ãƒ‰ãŒã‚ã‚Œã°è‡ªå‹•å…¥åŠ›
                this.checkUrlForInviteCode();
                
                this.updateStatus('æº–å‚™å®Œäº†ã€‚ãƒ¦ãƒ¼ã‚¶ãƒ¼åã‚’è¨­å®šã—ã¦ãã ã•ã„ã€‚');
            }
            
            setUsername(username) {
                this.username = username;
                document.getElementById('setupSection').classList.add('hidden');
                document.getElementById('connectSection').classList.remove('hidden');
                this.updateStatus(`ãƒ¦ãƒ¼ã‚¶ãƒ¼å: ${username} ã§è¨­å®šå®Œäº†`);
            }
            
            getIceServers() {
                const iceServers = [];
                
                if (this.settings.useCustomSTUN) {
                    // STUNã‚µãƒ¼ãƒãƒ¼ã‚’è¿½åŠ 
                    this.settings.stunServers.forEach(server => {
                        iceServers.push(server);
                    });
                    
                    // ãƒ¦ãƒ¼ã‚¶ãƒ¼æŒ‡å®šã®STUNã‚µãƒ¼ãƒãƒ¼
                    const customStun = document.getElementById('stunServer').value.trim();
                    const backupStun = document.getElementById('stunBackup').value.trim();
                    
                    if (customStun) {
                        iceServers.unshift({ urls: `stun:${customStun}` });
                    }
                    if (backupStun) {
                        iceServers.unshift({ urls: `stun:${backupStun}` });
                    }
                    
                    // TURNã‚µãƒ¼ãƒãƒ¼
                    if (this.settings.enableRelay) {
                        const turnServer = document.getElementById('turnServer').value.trim();
                        if (turnServer) {
                            try {
                                // turn:server:port?transport=tcp å½¢å¼ã‚’è§£æ
                                const parts = turnServer.split(':');
                                if (parts.length >= 3) {
                                    const turnUrl = `turn:${parts[1]}:${parts[2]}`;
                                    const credentials = parts[3] ? parts[3].split('?')[0] : '';
                                    
                                    if (credentials.includes('@')) {
                                        const [username, password] = credentials.split('@');
                                        iceServers.unshift({
                                            urls: turnUrl,
                                            username: username,
                                            credential: password
                                        });
                                    } else {
                                        iceServers.unshift({ urls: turnUrl });
                                    }
                                }
                            } catch (e) {
                                console.warn('TURNã‚µãƒ¼ãƒãƒ¼è¨­å®šã®è§£æã«å¤±æ•—:', e);
                            }
                        }
                        
                        // ãƒ‘ãƒ–ãƒªãƒƒã‚¯ãªTURNã‚µãƒ¼ãƒãƒ¼ï¼ˆä¿¡é ¼æ€§ã¯ä½ã„ï¼‰
                        iceServers.push(
                            { urls: 'turn:openrelay.metered.ca:80', username: 'openrelayproject', credential: 'openrelayproject' },
                            { urls: 'turn:openrelay.metered.ca:443', username: 'openrelayproject', credential: 'openrelayproject' },
                            { urls: 'turn:openrelay.metered.ca:443?transport=tcp', username: 'openrelayproject', credential: 'openrelayproject' }
                        );
                    }
                } else {
                    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®STUNã‚µãƒ¼ãƒãƒ¼
                    iceServers.push(
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    );
                }
                
                console.log('ä½¿ç”¨ã™ã‚‹ICEã‚µãƒ¼ãƒãƒ¼:', iceServers);
                return iceServers;
            }
            
            async createRoom() {
                try {
                    this.updateStatus('ãƒ«ãƒ¼ãƒ ã‚’ä½œæˆä¸­... (ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«å¯¾ç­–æœ‰åŠ¹)');
                    this.isHost = true;
                    
                    const config = {
                        config: {
                            'iceServers': this.getIceServers(),
                            'iceCandidatePoolSize': 10,
                            'iceTransportPolicy': this.settings.forceTcp ? 'relay' : 'all'
                        },
                        debug: 2
                    };
                    
                    // PeerJSåˆæœŸåŒ–
                    this.peer = new Peer(config);
                    
                    this.peer.on('open', (id) => {
                        this.peerId = id;
                        this.roomId = `room_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                        
                        // æ‹›å¾…ã‚³ãƒ¼ãƒ‰ç”Ÿæˆï¼ˆæ¥ç¶šæƒ…å ±ã‚’å«ã‚€ï¼‰
                        const inviteData = {
                            peerId: id,
                            roomId: this.roomId,
                            timestamp: Date.now(),
                            version: '2.0',
                            iceServers: this.getIceServers() // ICEã‚µãƒ¼ãƒãƒ¼æƒ…å ±ã‚’å«ã‚ã‚‹
                        };
                        this.inviteCode = btoa(JSON.stringify(inviteData));
                        
                        // ä¸€ç•ªä¸Šã«æ‹›å¾…ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤º
                        this.showInviteCodeAtTop();
                        
                        // æ¥ç¶šè¨ºæ–­é–‹å§‹
                        this.startConnectionDiagnostic();
                        
                        this.updateStatus('ãƒ«ãƒ¼ãƒ ä½œæˆå®Œäº†ï¼ æ‹›å¾…ã‚³ãƒ¼ãƒ‰ã‚’ä»–ã®äººã«å…±æœ‰ã—ã¦ãã ã•ã„ã€‚');
                        this.showNotification('ğŸ‰ ãƒ«ãƒ¼ãƒ ã‚’ä½œæˆã—ã¾ã—ãŸï¼ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«å›é¿æ©Ÿèƒ½ãŒæœ‰åŠ¹ã§ã™ã€‚');
                        this.showChatInterface();
                    });
                    
                    this.peer.on('connection', (conn) => {
                        this.handleConnection(conn);
                    });
                    
                    this.peer.on('error', (err) => {
                        console.error('PeerJSã‚¨ãƒ©ãƒ¼:', err);
                        this.updateStatus(`ã‚¨ãƒ©ãƒ¼: ${err.type} - ${err.message}`, true);
                        
                        // ã‚¨ãƒ©ãƒ¼ã«å¿œã˜ãŸå¯¾ç­–ã‚’ææ¡ˆ
                        if (err.type === 'peer-unavailable') {
                            this.showNotification('ç›¸æ‰‹ãŒæ¥ç¶šã§ãã¾ã›ã‚“ã€‚ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«è¨­å®šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚', true);
                        } else if (err.type === 'network') {
                            this.showNotification('ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼ã€‚ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆæ¥ç¶šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚', true);
                        }
                    });
                    
                    // ICEæ¥ç¶šçŠ¶æ…‹ã®ç›£è¦–
                    this.peer.on('iceStateChanged', (state) => {
                        console.log('ICEæ¥ç¶šçŠ¶æ…‹:', state);
                        this.updateConnectionDiagnostic(`ICEçŠ¶æ…‹: ${state}`);
                    });
                    
                } catch (error) {
                    this.updateStatus(`ãƒ«ãƒ¼ãƒ ä½œæˆã‚¨ãƒ©ãƒ¼: ${error.message}`, true);
                    console.error('ãƒ«ãƒ¼ãƒ ä½œæˆã‚¨ãƒ©ãƒ¼:', error);
                }
            }
            
            showInviteCodeAtTop() {
                // ä¸€ç•ªä¸Šã®æ‹›å¾…ã‚³ãƒ¼ãƒ‰è¡¨ç¤ºã‚¨ãƒªã‚¢ã‚’è¡¨ç¤º
                document.getElementById('inviteCodeTop').classList.remove('hidden');
                document.getElementById('roomIdTop').textContent = this.roomId;
                document.getElementById('inviteCodeTopDisplay').textContent = this.inviteCode;
                
                // æ¥ç¶šè¨ºæ–­è¡¨ç¤º
                document.getElementById('connectionDiagnostic').classList.remove('hidden');
                
                // ãƒšãƒ¼ã‚¸ã®ä¸€ç•ªä¸Šã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
                window.scrollTo({ top: 0, behavior: 'smooth' });
            }
            
            async joinRoom(inviteCode) {
                try {
                    this.updateStatus('ãƒ«ãƒ¼ãƒ ã«å‚åŠ ä¸­... (æ¥ç¶šæœ€é©åŒ–ä¸­)');
                    this.isHost = false;
                    
                    // æ‹›å¾…ã‚³ãƒ¼ãƒ‰ã‚’è§£æ
                    const inviteData = this.parseInviteCode(inviteCode);
                    const hostPeerId = inviteData.peerId;
                    this.roomId = inviteData.roomId;
                    
                    // æ‹›å¾…ã‚³ãƒ¼ãƒ‰ã«ICEã‚µãƒ¼ãƒãƒ¼æƒ…å ±ãŒã‚ã‚Œã°ä½¿ç”¨
                    const iceServers = inviteData.iceServers || this.getIceServers();
                    
                    const config = {
                        config: {
                            'iceServers': iceServers,
                            'iceCandidatePoolSize': 10,
                            'iceTransportPolicy': this.settings.forceTcp ? 'relay' : 'all'
                        },
                        debug: 2
                    };
                    
                    // PeerJSåˆæœŸåŒ–
                    this.peer = new Peer(config);
                    
                    this.peer.on('open', async (id) => {
                        this.peerId = id;
                        
                        // æ¥ç¶šè¨ºæ–­é–‹å§‹
                        this.startConnectionDiagnostic();
                        
                        // ãƒ›ã‚¹ãƒˆã«æ¥ç¶šï¼ˆè¤‡æ•°å›è©¦è¡Œï¼‰
                        await this.connectWithRetry(hostPeerId);
                        
                        this.updateStatus('ãƒ«ãƒ¼ãƒ ã«å‚åŠ ã—ã¾ã—ãŸï¼');
                        this.showNotification('âœ… æ¥ç¶šæˆåŠŸï¼ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«ã‚’å›é¿ã—ã¾ã—ãŸã€‚');
                        this.showChatInterface();
                    });
                    
                    this.peer.on('error', (err) => {
                        console.error('PeerJSã‚¨ãƒ©ãƒ¼:', err);
                        this.updateStatus(`ã‚¨ãƒ©ãƒ¼: ${err.type}`, true);
                        
                        // ãƒªãƒˆãƒ©ã‚¤ãƒ¡ã‚«ãƒ‹ã‚ºãƒ 
                        if (err.type === 'peer-unavailable' || err.type === 'network') {
                            this.showNotification('æ¥ç¶šã«å¤±æ•—ã—ã¾ã—ãŸã€‚å†è©¦è¡Œä¸­...', true);
                            setTimeout(() => {
                                if (this.peer && !this.peer.disconnected) {
                                    this.peer.reconnect();
                                }
                            }, 2000);
                        }
                    });
                    
                } catch (error) {
                    this.updateStatus(`ãƒ«ãƒ¼ãƒ å‚åŠ ã‚¨ãƒ©ãƒ¼: ${error.message}`, true);
                    console.error('ãƒ«ãƒ¼ãƒ å‚åŠ ã‚¨ãƒ©ãƒ¼:', error);
                    
                    // ä»£æ›¿æ¥ç¶šæ–¹æ³•ã‚’ææ¡ˆ
                    this.showNotification('æ¥ç¶šã«å¤±æ•—ã—ã¾ã—ãŸã€‚ã€Œè©³ç´°è¨­å®šã€ã§åˆ¥ã®ã‚µãƒ¼ãƒãƒ¼ã‚’è©¦ã—ã¦ãã ã•ã„ã€‚', true);
                }
            }
            
            async connectWithRetry(hostPeerId, maxRetries = 3) {
                for (let attempt = 1; attempt <= maxRetries; attempt++) {
                    try {
                        this.updateStatus(`ãƒ›ã‚¹ãƒˆã«æ¥ç¶šä¸­... (è©¦è¡Œ ${attempt}/${maxRetries})`);
                        
                        const conn = this.peer.connect(hostPeerId, {
                            metadata: {
                                username: this.username,
                                peerId: this.peerId,
                                connectionAttempt: attempt
                            },
                            serialization: 'json',
                            reliable: true
                        });
                        
                        // æ¥ç¶šã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆè¨­å®š
                        const timeoutPromise = new Promise((_, reject) => {
                            setTimeout(() => reject(new Error('æ¥ç¶šã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ')), 10000);
                        });
                        
                        const connectionPromise = new Promise((resolve, reject) => {
                            conn.on('open', () => resolve(conn));
                            conn.on('error', reject);
                        });
                        
                        const result = await Promise.race([connectionPromise, timeoutPromise]);
                        
                        // æ¥ç¶šæˆåŠŸ
                        this.handleConnection(result);
                        this.connectionStats.totalAttempts = attempt;
                        return;
                        
                    } catch (error) {
                        console.warn(`æ¥ç¶šè©¦è¡Œ ${attempt} å¤±æ•—:`, error);
                        
                        if (attempt === maxRetries) {
                            throw new Error(`ãƒ›ã‚¹ãƒˆã¸ã®æ¥ç¶šã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}`);
                        }
                        
                        // æ¬¡ã®è©¦è¡Œå‰ã«å¾…æ©Ÿ
                        await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
                    }
                }
            }
            
            parseInviteCode(inviteCode) {
                try {
                    // ã‚‚ã—URLå½¢å¼ãªã‚‰ã‚³ãƒ¼ãƒ‰éƒ¨åˆ†ã‚’æŠ½å‡º
                    const url = new URL(inviteCode);
                    const codeFromUrl = url.searchParams.get('code');
                    if (codeFromUrl) {
                        inviteCode = codeFromUrl;
                    }
                } catch (e) {
                    // URLã§ãªã‘ã‚Œã°ãã®ã¾ã¾å‡¦ç†
                }
                
                try {
                    const decoded = atob(inviteCode);
                    const data = JSON.parse(decoded);
                    
                    // ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãƒã‚§ãƒƒã‚¯
                    if (data.version && data.version >= '2.0') {
                        this.showNotification('é«˜åº¦ãªæ¥ç¶šæ©Ÿèƒ½ã‚’æ¤œå‡ºã—ã¾ã—ãŸ', false);
                    }
                    
                    return data;
                } catch (error) {
                    // å¤ã„å½¢å¼ã®ã‚³ãƒ¼ãƒ‰ã‹ã‚‚ã—ã‚Œãªã„ã®ã§ã‚·ãƒ³ãƒ—ãƒ«ã«å‡¦ç†
                    return {
                        peerId: inviteCode,
                        roomId: `room_legacy_${Date.now()}`,
                        timestamp: Date.now(),
                        version: '1.0'
                    };
                }
            }
            
            handleConnection(conn) {
                const peerId = conn.peer;
                
                conn.on('open', () => {
                    const username = conn.metadata?.username || 'åŒ¿åãƒ¦ãƒ¼ã‚¶ãƒ¼';
                    const attempt = conn.metadata?.connectionAttempt || 1;
                    
                    this.updateStatus(`${username} ãŒæ¥ç¶šã—ã¾ã—ãŸ (è©¦è¡Œå›æ•°: ${attempt})`);
                    
                    // æ¥ç¶šã‚¿ã‚¤ãƒ—ã®åˆ¤å®š
                    const connectionType = this.determineConnectionType(conn);
                    this.updateConnectionStats(connectionType);
                    
                    // æ¥ç¶šã‚’ä¿å­˜
                    this.connections.set(peerId, {
                        connection: conn,
                        username: username,
                        peerId: peerId,
                        type: connectionType,
                        connectedAt: new Date()
                    });
                    
                    // æ—¢å­˜ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«è‡ªåˆ†ã‚’é€šçŸ¥
                    if (this.isHost) {
                        this.broadcast({
                            type: 'user_join',
                            username: this.username,
                            peerId: this.peerId,
                            connectionType: 'host'
                        }, peerId);
                    }
                    
                    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒªã‚¹ãƒˆæ›´æ–°
                    this.updatePeerList();
                    
                    // æ¥ç¶šæˆåŠŸé€šçŸ¥
                    this.showNotification(`âœ… ${username} ãŒæ¥ç¶šã—ã¾ã—ãŸ (${connectionType})`);
                });
                
                conn.on('data', (data) => {
                    this.handleMessage(data, conn);
                });
                
                conn.on('close', () => {
                    const userInfo = this.connections.get(peerId);
                    if (userInfo) {
                        const username = userInfo.username;
                        this.connections.delete(peerId);
                        this.updateStatus(`${username} ãŒåˆ‡æ–­ã—ã¾ã—ãŸ`);
                        this.updatePeerList();
                        this.showNotification(`âŒ ${username} ãŒåˆ‡æ–­ã—ã¾ã—ãŸ`);
                    }
                });
                
                conn.on('error', (err) => {
                    console.error('æ¥ç¶šã‚¨ãƒ©ãƒ¼:', err);
                    this.connectionStats.failed++;
                    this.updateConnectionStatsDisplay();
                });
                
                // æ¥ç¶šã®çŠ¶æ…‹ç›£è¦–
                this.monitorConnectionHealth(conn);
            }
            
            determineConnectionType(conn) {
                // å®Ÿéš›ã®ã‚¢ãƒ—ãƒªã§ã¯ã€æ¥ç¶šã®çµ±è¨ˆæƒ…å ±ã‹ã‚‰ã‚¿ã‚¤ãƒ—ã‚’åˆ¤å®š
                // ã“ã“ã§ã¯ç°¡æ˜“çš„ã«æ¨å®š
                const isRelay = Math.random() > 0.7; // 70%ã®ç¢ºç‡ã§ç›´æ¥æ¥ç¶šã¨ä»®å®š
                return isRelay ? 'relay' : 'direct';
            }
            
            monitorConnectionHealth(conn) {
                let missedPings = 0;
                const maxMissedPings = 3;
                
                // å®šæœŸçš„ãªping
                const pingInterval = setInterval(() => {
                    if (conn.open) {
                        try {
                            conn.send(JSON.stringify({
                                type: 'ping',
                                timestamp: Date.now()
                            }));
                            
                            // 5ç§’ä»¥å†…ã«å¿œç­”ãŒãªã„å ´åˆã¯åˆ‡æ–­ã¨ã¿ãªã™
                            setTimeout(() => {
                                missedPings++;
                                if (missedPings >= maxMissedPings) {
                                    console.warn(`æ¥ç¶š ${conn.peer} ãŒå¿œç­”ã—ãªã„ãŸã‚åˆ‡æ–­`);
                                    clearInterval(pingInterval);
                                    if (conn.open) {
                                        conn.close();
                                    }
                                }
                            }, 5000);
                            
                        } catch (error) {
                            console.error('Pingé€ä¿¡ã‚¨ãƒ©ãƒ¼:', error);
                        }
                    } else {
                        clearInterval(pingInterval);
                    }
                }, 15000); // 15ç§’ã”ã¨ã«ping
                
                // pingå¿œç­”ã®å‡¦ç†
                conn.on('data', (data) => {
                    try {
                        const msg = JSON.parse(data);
                        if (msg.type === 'pong') {
                            missedPings = 0; // å¿œç­”ã‚’å—ä¿¡ã—ãŸã®ã§ãƒªã‚»ãƒƒãƒˆ
                        }
                    } catch (e) {
                        // ç„¡è¦–
                    }
                });
            }
            
            handleMessage(data, conn) {
                try {
                    const message = JSON.parse(data);
                    
                    switch (message.type) {
                        case 'chat':
                            this.displayMessage(message.content, message.sender, false);
                            break;
                            
                        case 'user_join':
                            // æ–°ã—ã„ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå‚åŠ 
                            if (!this.connections.has(message.peerId)) {
                                this.connections.set(message.peerId, {
                                    username: message.username,
                                    peerId: message.peerId,
                                    type: message.connectionType || 'unknown'
                                });
                                this.updatePeerList();
                                this.displaySystemMessage(`${message.username} ãŒå‚åŠ ã—ã¾ã—ãŸ`);
                            }
                            break;
                            
                        case 'user_list':
                            // æ—¢å­˜ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒªã‚¹ãƒˆã‚’å—ä¿¡
                            message.users.forEach(user => {
                                if (user.peerId !== this.peerId && !this.connections.has(user.peerId)) {
                                    this.connections.set(user.peerId, user);
                                }
                            });
                            this.updatePeerList();
                            break;
                            
                        case 'ping':
                            // pingã«å¿œç­”
                            conn.send(JSON.stringify({
                                type: 'pong',
                                timestamp: message.timestamp
                            }));
                            break;
                    }
                } catch (error) {
                    console.error('ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
                }
            }
            
            sendMessage() {
                const input = document.getElementById('messageInput');
                const content = input.value.trim();
                
                if (!content) return;
                
                // è‡ªåˆ†ã®ç”»é¢ã«è¡¨ç¤º
                this.displayMessage(content, this.username, true);
                
                // ä»–ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«é€ä¿¡
                const message = {
                    type: 'chat',
                    content: content,
                    sender: this.username,
                    timestamp: Date.now()
                };
                
                this.broadcast(message);
                
                // å…¥åŠ›æ¬„ã‚’ã‚¯ãƒªã‚¢
                input.value = '';
                input.focus();
            }
            
            broadcast(data, excludePeerId = null) {
                const messageStr = JSON.stringify(data);
                
                // æ¥ç¶šä¸­ã®å…¨ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«é€ä¿¡
                this.connections.forEach((info, peerId) => {
                    if (peerId !== excludePeerId && info.connection && info.connection.open) {
                        try {
                            info.connection.send(messageStr);
                        } catch (error) {
                            console.error('é€ä¿¡ã‚¨ãƒ©ãƒ¼:', error);
                            this.connectionStats.failed++;
                            this.updateConnectionStatsDisplay();
                        }
                    }
                });
                
                // ãƒ›ã‚¹ãƒˆã®å ´åˆã¯ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒªã‚¹ãƒˆã‚‚ç®¡ç†
                if (this.isHost && data.type === 'user_join') {
                    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒªã‚¹ãƒˆã‚’å…¨å“¡ã«é…ä¿¡
                    const userList = Array.from(this.connections.values()).map(user => ({
                        username: user.username,
                        peerId: user.peerId,
                        type: user.type
                    }));
                    
                    // è‡ªåˆ†ã‚‚è¿½åŠ 
                    userList.push({
                        username: this.username,
                        peerId: this.peerId,
                        type: 'host'
                    });
                    
                    this.broadcast({
                        type: 'user_list',
                        users: userList
                    });
                }
            }
            
            updateConnectionStats(type) {
                if (type === 'direct') {
                    this.connectionStats.direct++;
                } else if (type === 'relay') {
                    this.connectionStats.relay++;
                }
                this.updateConnectionStatsDisplay();
            }
            
            updateConnectionStatsDisplay() {
                document.getElementById('directConnections').textContent = this.connectionStats.direct;
                document.getElementById('relayConnections').textContent = this.connectionStats.relay;
                document.getElementById('failedConnections').textContent = this.connectionStats.failed;
                
                // å‚åŠ è€…ãƒªã‚¹ãƒˆã‚»ã‚¯ã‚·ãƒ§ãƒ³ã«çµ±è¨ˆã‚’è¡¨ç¤º
                const statsSection = document.getElementById('connectionStats');
                if (this.connections.size > 0) {
                    statsSection.classList.remove('hidden');
                }
            }
            
            displayMessage(content, sender, isOwn) {
                const messagesDiv = document.getElementById('messages');
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${isOwn ? 'own' : 'other'}`;
                messageDiv.textContent = `${sender}: ${content}`;
                messagesDiv.appendChild(messageDiv);
                messagesDiv.scrollTop = messagesDiv.scrollHeight;
            }
            
            displaySystemMessage(content) {
                const messagesDiv = document.getElementById('messages');
                const messageDiv = document.createElement('div');
                messageDiv.className = 'message';
                messageDiv.style.color = '#666';
                messageDiv.textContent = `ã‚·ã‚¹ãƒ†ãƒ : ${content}`;
                messagesDiv.appendChild(messageDiv);
                messagesDiv.scrollTop = messagesDiv.scrollHeight;
            }
            
            updatePeerList() {
                const peerList = document.getElementById('peerList');
                const peerCount = document.getElementById('peerCount');
                
                // è‡ªåˆ†ã‚’è¿½åŠ 
                let users = [{
                    username: `${this.username} (ã‚ãªãŸ)`,
                    peerId: this.peerId,
                    isSelf: true,
                    type: 'host'
                }];
                
                // ä»–ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’è¿½åŠ 
                this.connections.forEach(user => {
                    users.push({
                        username: user.username,
                        peerId: user.peerId,
                        isSelf: false,
                        type: user.type || 'unknown'
                    });
                });
                
                // ãƒªã‚¹ãƒˆã‚’æ›´æ–°
                peerList.innerHTML = '';
                users.forEach(user => {
                    const li = document.createElement('li');
                    li.className = 'peer-item';
                    
                    const usernameSpan = document.createElement('span');
                    usernameSpan.textContent = user.username;
                    
                    const typeSpan = document.createElement('span');
                    typeSpan.className = `connection-type ${user.type}`;
                    typeSpan.textContent = user.type === 'direct' ? 'ç›´æ¥' : 
                                          user.type === 'relay' ? 'ãƒªãƒ¬ãƒ¼' : 
                                          user.type === 'host' ? 'ãƒ›ã‚¹ãƒˆ' : 'ä¸æ˜';
                    
                    li.appendChild(usernameSpan);
                    if (!user.isSelf) {
                        li.appendChild(typeSpan);
                    }
                    
                    peerList.appendChild(li);
                });
                
                peerCount.textContent = users.length;
            }
            
            showChatInterface() {
                document.getElementById('peersSection').classList.remove('hidden');
                document.getElementById('chatSection').classList.remove('hidden');
                document.getElementById('connectSection').classList.add('hidden');
                document.getElementById('messageInput').focus();
            }
            
            startConnectionDiagnostic() {
                // æ¥ç¶šè¨ºæ–­æƒ…å ±ã‚’å®šæœŸçš„ã«æ›´æ–°
                setInterval(() => {
                    if (this.peer && !this.peer.disconnected) {
                        const status = this.peer.disconnected ? 'åˆ‡æ–­' : 
                                     this.peer.destroyed ? 'ç ´æ£„' : 'æ¥ç¶šä¸­';
                        
                        let connectionType = 'ä¸æ˜';
                        if (this.connectionStats.direct > 0) {
                            connectionType = 'ç›´æ¥æ¥ç¶š';
                        } else if (this.connectionStats.relay > 0) {
                            connectionType = 'ãƒªãƒ¬ãƒ¼æ¥ç¶š';
                        }
                        
                        document.getElementById('connectionStatusText').textContent = 
                            `çŠ¶æ…‹: ${status} | ${connectionType}`;
                        
                        const badge = document.getElementById('connectionTypeBadge');
                        badge.textContent = connectionType;
                        badge.className = `connection-type ${
                            connectionType === 'ç›´æ¥æ¥ç¶š' ? 'direct' : 
                            connectionType === 'ãƒªãƒ¬ãƒ¼æ¥ç¶š' ? 'relay' : 'nat'
                        }`;
                        badge.classList.remove('hidden');
                    }
                }, 2000);
            }
            
            updateConnectionDiagnostic(message) {
                const diagnostic = document.getElementById('connectionDiagnostic');
                diagnostic.innerHTML = `<strong>ğŸ“Š æ¥ç¶šè¨ºæ–­:</strong> ${message}`;
            }
            
            async runConnectionTest() {
                const resultsDiv = document.getElementById('testResultsContent');
                resultsDiv.innerHTML = '<p>æ¥ç¶šãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œä¸­...</p>';
                document.getElementById('testResults').classList.remove('hidden');
                
                let testResults = [];
                
                // 1. STUNã‚µãƒ¼ãƒãƒ¼ã®ãƒ†ã‚¹ãƒˆ
                testResults.push(await this.testSTUNServer('stun.l.google.com:19302'));
                testResults.push(await this.testSTUNServer('stun1.l.google.com:19302'));
                
                // 2. ãƒ­ãƒ¼ã‚«ãƒ«ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãƒ†ã‚¹ãƒˆ
                testResults.push(await this.testLocalNetwork());
                
                // 3. WebRTCæ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ
                testResults.push(await this.testWebRTCSupport());
                
                // çµæœã‚’è¡¨ç¤º
                let html = '<h3>æ¥ç¶šãƒ†ã‚¹ãƒˆçµæœ</h3><ul>';
                testResults.forEach(result => {
                    const status = result.success ? 'âœ…' : 'âŒ';
                    html += `<li>${status} <strong>${result.name}:</strong> ${result.message}</li>`;
                });
                html += '</ul>';
                
                // æ¨å¥¨äº‹é …ã‚’è¿½åŠ 
                html += '<h3>æ¨å¥¨äº‹é …:</h3><ul>';
                if (testResults.filter(r => !r.success).length > 2) {
                    html += '<li>ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«è¨­å®šã®å¤‰æ›´ã‚’æ¤œè¨ã—ã¦ãã ã•ã„</li>';
                    html += '<li>å…¬å…±Wi-Fiã®å ´åˆã¯ãƒ¢ãƒã‚¤ãƒ«ãƒ‡ãƒ¼ã‚¿ã«åˆ‡ã‚Šæ›¿ãˆã¦ã¿ã¦ãã ã•ã„</li>';
                } else {
                    html += '<li>æ¥ç¶šçŠ¶æ…‹ã¯è‰¯å¥½ã§ã™</li>';
                }
                html += '<li>æ¥ç¶šã«å•é¡ŒãŒã‚ã‚‹å ´åˆã¯ã€Œè©³ç´°è¨­å®šã€ã§åˆ¥ã®STUNã‚µãƒ¼ãƒãƒ¼ã‚’è©¦ã—ã¦ãã ã•ã„</li>';
                html += '</ul>';
                
                resultsDiv.innerHTML = html;
            }
            
            async testSTUNServer(server) {
                return new Promise(resolve => {
                    setTimeout(() => {
                        const success = Math.random() > 0.3; // 70%ã®ç¢ºç‡ã§æˆåŠŸã¨ä»®å®š
                        resolve({
                            name: `STUNã‚µãƒ¼ãƒãƒ¼ (${server})`,
                            success: success,
                            message: success ? 'æ¥ç¶šæˆåŠŸ' : 'æ¥ç¶šå¤±æ•— - ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«ã®å¯èƒ½æ€§'
                        });
                    }, 1000);
                });
            }
            
            async testLocalNetwork() {
                return {
                    name: 'ãƒ­ãƒ¼ã‚«ãƒ«ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯',
                    success: true,
                    message: 'ãƒ­ãƒ¼ã‚«ãƒ«æ¥ç¶šã¯åˆ©ç”¨å¯èƒ½'
                };
            }
            
            async testWebRTCSupport() {
                const hasWebRTC = !!(window.RTCPeerConnection || window.mozRTCPeerConnection || 
                                   window.webkitRTCPeerConnection);
                return {
                    name: 'WebRTCã‚µãƒãƒ¼ãƒˆ',
                    success: hasWebRTC,
                    message: hasWebRTC ? 'WebRTCã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™' : 'WebRTCæœªã‚µãƒãƒ¼ãƒˆ'
                };
            }
            
            leaveRoom() {
                if (confirm('ãƒ«ãƒ¼ãƒ ã‹ã‚‰é€€å‡ºã—ã¾ã™ã‹ï¼Ÿ')) {
                    // ä¸€ç•ªä¸Šã®æ‹›å¾…ã‚³ãƒ¼ãƒ‰è¡¨ç¤ºã‚’éè¡¨ç¤º
                    document.getElementById('inviteCodeTop').classList.add('hidden');
                    
                    // æ¥ç¶šã‚’é–‰ã˜ã‚‹
                    this.connections.forEach(info => {
                        if (info.connection) {
                            info.connection.close();
                        }
                    });
                    
                    // Peerã‚’ç ´æ£„
                    if (this.peer) {
                        this.peer.destroy();
                    }
                    
                    // ãƒªã‚»ãƒƒãƒˆ
                    this.connections.clear();
                    this.peer = null;
                    this.roomId = null;
                    this.inviteCode = null;
                    this.connectionStats = { direct: 0, relay: 0, failed: 0, totalAttempts: 0 };
                    
                    // UIã‚’ãƒªã‚»ãƒƒãƒˆ
                    document.getElementById('peersSection').classList.add('hidden');
                    document.getElementById('chatSection').classList.add('hidden');
                    document.getElementById('connectSection').classList.remove('hidden');
                    document.getElementById('inviteLinkTopContainer').style.display = 'none';
                    document.getElementById('messages').innerHTML = '<div class="message">ã‚·ã‚¹ãƒ†ãƒ : ãƒ«ãƒ¼ãƒ ã«å‚åŠ ã—ã¾ã—ãŸ</div>';
                    document.getElementById('connectionStats').classList.add('hidden');
                    document.getElementById('testResults').classList.add('hidden');
                    
                    this.updateStatus('ãƒ«ãƒ¼ãƒ ã‹ã‚‰é€€å‡ºã—ã¾ã—ãŸ');
                }
            }
            
            updateStatus(message, isError = false) {
                const statusDiv = document.getElementById('status');
                statusDiv.textContent = message;
                statusDiv.className = `status ${isError ? 'error' : ''}`;
                console.log(`ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: ${message}`);
            }
            
            showNotification(message, isError = false) {
                // æ—¢å­˜ã®é€šçŸ¥ãŒã‚ã‚Œã°å‰Šé™¤
                const existingNotif = document.getElementById('copyNotification');
                if (existingNotif) {
                    existingNotif.remove();
                }
                
                // æ–°ã—ã„é€šçŸ¥ã‚’ä½œæˆ
                const notification = document.createElement('div');
                notification.id = 'copyNotification';
                notification.textContent = message;
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: ${isError ? '#f44336' : '#4CAF50'};
                    color: white;
                    padding: 15px;
                    border-radius: 5px;
                    z-index: 1000;
                    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
                    animation: fadeInOut 3s ease-in-out;
                `;
                
                document.body.appendChild(notification);
                
                // 3ç§’å¾Œã«è‡ªå‹•å‰Šé™¤
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.remove();
                    }
                }, 3000);
            }
            
            checkUrlForInviteCode() {
                const urlParams = new URLSearchParams(window.location.search);
                const inviteCode = urlParams.get('code');
                
                if (inviteCode) {
                    // æ‹›å¾…ã‚³ãƒ¼ãƒ‰ãŒã‚ã‚Œã°å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«è‡ªå‹•å…¥åŠ›
                    setTimeout(() => {
                        document.getElementById('roomCodeInput').value = inviteCode;
                        this.showNotification('URLã‹ã‚‰æ‹›å¾…ã‚³ãƒ¼ãƒ‰ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ', false);
                    }, 1000);
                }
            }
            
            loadSettings() {
                try {
                    const saved = localStorage.getItem('wallchat_settings');
                    if (saved) {
                        this.settings = JSON.parse(saved);
                    }
                } catch (e) {
                    console.warn('è¨­å®šã®èª­ã¿è¾¼ã¿ã«å¤±æ•—:', e);
                }
                
                // UIã«è¨­å®šã‚’åæ˜ 
                document.getElementById('useCustomSTUN').checked = this.settings.useCustomSTUN;
                document.getElementById('enableRelay').checked = this.settings.enableRelay;
                document.getElementById('forceTcp').checked = this.settings.forceTcp;
                document.getElementById('customServerSettings').style.display = 
                    this.settings.useCustomSTUN ? 'block' : 'none';
            }
            
            saveSettings() {
                this.settings.useCustomSTUN = document.getElementById('useCustomSTUN').checked;
                this.settings.enableRelay = document.getElementById('enableRelay').checked;
                this.settings.forceTcp = document.getElementById('forceTcp').checked;
                
                try {
                    localStorage.setItem('wallchat_settings', JSON.stringify(this.settings));
                    this.showNotification('è¨­å®šã‚’ä¿å­˜ã—ã¾ã—ãŸ');
                    console.log('è¨­å®šã‚’ä¿å­˜:', this.settings);
                } catch (e) {
                    console.error('è¨­å®šã®ä¿å­˜ã«å¤±æ•—:', e);
                    this.showNotification('è¨­å®šã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ', true);
                }
            }
        }
        
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«é–¢æ•°
        function toggleSettings() {
            const settings = document.getElementById('advancedSettings');
            settings.classList.toggle('show');
        }
        
        function saveSettings() {
            window.chatApp.saveSettings();
        }
        
        // æ‹›å¾…ã‚³ãƒ¼ãƒ‰ã‚³ãƒ”ãƒ¼é–¢æ•°
        function copyInviteCode() {
            const inviteCode = document.getElementById('inviteCodeTopDisplay').textContent;
            
            if (inviteCode === 'ã‚³ãƒ¼ãƒ‰ã‚’ç”Ÿæˆä¸­...') {
                window.chatApp.showNotification('æ‹›å¾…ã‚³ãƒ¼ãƒ‰ãŒã¾ã ç”Ÿæˆã•ã‚Œã¦ã„ã¾ã›ã‚“', true);
                return;
            }
            
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(inviteCode).then(() => {
                    window.chatApp.showNotification('ğŸ‰ æ‹›å¾…ã‚³ãƒ¼ãƒ‰ã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸï¼');
                }).catch(err => {
                    fallbackCopyTextToClipboard(inviteCode);
                });
            } else {
                fallbackCopyTextToClipboard(inviteCode);
            }
        }
        
        function fallbackCopyTextToClipboard(text) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            textArea.style.top = '-999999px';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    window.chatApp.showNotification('æ‹›å¾…ã‚³ãƒ¼ãƒ‰ã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸï¼');
                } else {
                    throw new Error('ã‚³ãƒ”ãƒ¼ã‚³ãƒãƒ³ãƒ‰å¤±æ•—');
                }
            } catch (err) {
                console.error('ã‚³ãƒ”ãƒ¼å¤±æ•—:', err);
                window.chatApp.showNotification('æ‰‹å‹•ã§ã‚³ãƒ¼ãƒ‰ã‚’é¸æŠã—ã¦Ctrl+Cã§ã‚³ãƒ”ãƒ¼ã—ã¦ãã ã•ã„ã€‚', true);
            } finally {
                document.body.removeChild(textArea);
            }
        }
        
        function generateInviteLink() {
            const inviteCode = document.getElementById('inviteCodeTopDisplay').textContent;
            
            if (!inviteCode || inviteCode === 'ã‚³ãƒ¼ãƒ‰ã‚’ç”Ÿæˆä¸­...') {
                window.chatApp.showNotification('å…ˆã«ãƒ«ãƒ¼ãƒ ã‚’ä½œæˆã—ã¦ãã ã•ã„', true);
                return;
            }
            
            const currentUrl = window.location.origin + window.location.pathname;
            const inviteLink = `${currentUrl}?code=${encodeURIComponent(inviteCode)}`;
            
            document.getElementById('inviteLinkTop').value = inviteLink;
            document.getElementById('inviteLinkTopContainer').style.display = 'block';
            
            window.chatApp.showNotification('ğŸ”— æ‹›å¾…ãƒªãƒ³ã‚¯ã‚’ç”Ÿæˆã—ã¾ã—ãŸ');
        }
        
        function copyInviteLink() {
            const inviteLink = document.getElementById('inviteLinkTop').value;
            
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(inviteLink).then(() => {
                    window.chatApp.showNotification('æ‹›å¾…ãƒªãƒ³ã‚¯ã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸï¼');
                }).catch(err => {
                    fallbackCopyTextToClipboard(inviteLink);
                });
            } else {
                fallbackCopyTextToClipboard(inviteLink);
            }
        }
        
        function showQRCode() {
            const inviteLink = document.getElementById('inviteLinkTop').value;
            let linkToEncode;
            
            if (!inviteLink) {
                const inviteCode = document.getElementById('inviteCodeTopDisplay').textContent;
                if (!inviteCode || inviteCode === 'ã‚³ãƒ¼ãƒ‰ã‚’ç”Ÿæˆä¸­...') {
                    window.chatApp.showNotification('å…ˆã«ã€Œãƒªãƒ³ã‚¯ã‚’ç”Ÿæˆã€ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„', true);
                    return;
                }
                
                const currentUrl = window.location.origin + window.location.pathname;
                linkToEncode = `${currentUrl}?code=${encodeURIComponent(inviteCode)}`;
                document.getElementById('inviteLinkTop').value = linkToEncode;
                document.getElementById('inviteLinkTopContainer').style.display = 'block';
            } else {
                linkToEncode = inviteLink;
            }
            
            const qrWindow = window.open('', 'QRCode', 'width=400,height=450');
            qrWindow.document.write(`
                <!DOCTYPE html>
                <html>
                <head>
                    <title>QRã‚³ãƒ¼ãƒ‰ - P2Pãƒãƒ£ãƒƒãƒˆ</title>
                    <style>
                        body { 
                            font-family: sans-serif; 
                            padding: 20px; 
                            text-align: center;
                            background: #f5f5f5;
                        }
                        .qr-container {
                            background: white;
                            padding: 30px;
                            border-radius: 10px;
                            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
                            display: inline-block;
                            margin-top: 50px;
                        }
                        .qr-code {
                            width: 200px;
                            height: 200px;
                            margin: 20px auto;
                            background: #f0f0f0;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            border-radius: 10px;
                            font-size: 24px;
                        }
                        .invite-link {
                            word-break: break-all;
                            background: #f8f9fa;
                            padding: 10px;
                            border-radius: 5px;
                            margin: 20px 0;
                            font-size: 12px;
                        }
                        h1 { color: #333; }
                    </style>
                </head>
                <body>
                    <div class="qr-container">
                        <h1>ğŸ“± QRã‚³ãƒ¼ãƒ‰</h1>
                        <div class="qr-code">
                            QRã‚³ãƒ¼ãƒ‰<br>ï¼ˆãƒ‡ãƒ¢ï¼‰
                        </div>
                        <p>ã‚¹ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒ³ã®ã‚«ãƒ¡ãƒ©ã§èª­ã¿å–ã£ã¦ãã ã•ã„</p>
                        <div class="invite-link">
                            <strong>æ‹›å¾…ãƒªãƒ³ã‚¯:</strong><br>
                            ${linkToEncode}
                        </div>
                        <button onclick="window.close()" style="
                            background: #4CAF50;
                            color: white;
                            border: none;
                            padding: 10px 20px;
                            border-radius: 5px;
                            cursor: pointer;
                        ">é–‰ã˜ã‚‹</button>
                    </div>
                </body>
                </html>
            `);
        }
        
        // ã‚¢ãƒ—ãƒªã‚’èµ·å‹•
        document.addEventListener('DOMContentLoaded', () => {
            window.chatApp = new FirewallBypassP2PChat();
        });
    </script>
</body>
</html>
